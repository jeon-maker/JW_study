1. [BOJ2477](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ2477.java)

구현 - 성공

6각형의 모양이 특정되어 있기 때문에 가장 큰 가로 길이, 가장 큰 세로 길이를 곱해서 큰 틀 사각형의 넓이를 구한 뒤 작은 사각형 (빈 사각형)의 넓이를 빼주는 방식을 택하였다. 빈 사각형의 넓이를 빼주기 위해선 "1313","2323","1414","2424","3131","4141","3232","4242" 과 같은 2개의 숫자가 연속으로 반복되는 부분이 필연적으로 나오는데, 이때 중간 두개의 값을 곱해서 빼주면 된다. 주의할 점은 시작점이 특정되어있지 않기 때문에, 입력받은 숫자 6자리를 한번 더 그대로 붙여서 12자리로 만든 뒤에 최초로 반복되는 부분을 찾으면 된다.


2. [BOJ14247](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ14247.java)

그리디 - 성공

실패했던 원인 (메모리 초과 + 시간 초과) - 쓸데없이 2차원 배열 사용을 했음.

가장 빠르게 자라는 것을 늦게 자를수록 이득이다. 한 나무를 여러번 자를 수 있다는 조건이 있지만, 그냥 무조건 많은 나무들을 자르면서 빨리 자라는 나무는 늦게 자르는게 더 큰 양을 얻게 된다.
![image](https://user-images.githubusercontent.com/77326600/213654157-1d14c5aa-0cc0-447c-95d9-8d731a597926.png)
이 부분을 int로 하면 틀렸고, Long으로 하면 맞았다. 이유가 뭘까?

int는 4바이트이다 . 32비트로 양수,음수를 다 표현하기 때문에 -2,147,483,648부터 2,147,483,647까지의 값을 저장할 수 있다.문제의 조건에서 나무의 개수가 100,000개 까지 가능하고 , 나무들의 초기 길이가 100,000개, 자라는 속도가 10,000까지 가능하기 때문에 모두 최대값을 찍은 경우에는 100,000,000,000,000까지 답이 나올 수 있다.
따라서 int로 표현 가능한 범위를 초과하여 오답이 나오게 되는 듯 하다.
long은 8바이트로 64비트이다. 9,223,372,036,854,775,807까지 표현 가능하다.

참고로 Long과 Integer는 null을 사용할 수 있지만 long, int는 null을 사용할 수 없다.

앞으로 큰 범위의 수를 다루는 듯 하면 Long을 사용하도록 하자.

3.[BOJ1912](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ1912.java)

DP - 실패

DP는 역시 어렵다. dp 방식으로 풀어야 하는데 그렇지 못하게 풀어서 메모리 초과로 실패했다.

메모이제이션으로 풀어야 한다.
메모이제이션은 이전까지 탐색했던 값과 현재 위치의 값을 비교하여 큰 값을 저장하면 되는 것이다.
![image](https://user-images.githubusercontent.com/77326600/213665046-fd937373-c960-49d8-9793-12bff1bf55c9.png)
DP를 잘 풀 수 있다면 매우 쉬운 문제라고 한다.
DP를 풀 때 재귀를 이용해야 하는데 나는 항상 재귀를 생각 못하고 풀어왔다.
재귀를 사용해서 DP를 풀어야 한다는 것을 기억하면 좀 더 쉽게 접근할 수 있을 것 같다. 


4.[BOJ11053](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ11053.java)

DP - 실패

![image](https://user-images.githubusercontent.com/77326600/213871345-3649c6f0-75ee-41df-9e7c-b68ee7dde006.png

내 실패 코드이다.
반례를 찾았다.
9
1 2 3 4 5 1 2 3 4
를 입력하면 8이 출력된다. 직전의 값에만 비교를 해주기 때문인듯 하다. 직전 배열의 값에만 비교를 해주는게 아닌 다른 방법을 찾아야 한다. 뒤에 큰 숫자가 나오더라도 건너 뛸 수 있는 기능을 추가해야한다.

어렵다.. 실패 ㅠㅡㅠ

정답 코드
![image](https://user-images.githubusercontent.com/77326600/213872758-ee2911ae-f5b5-458a-b827-9511758da85a.png)


손코딩으로 써보니 이해가 되었다. 각 원소에서 이전 원소들에 대한 검증을 싹 다 해야한다. 재귀함수를 만들어서, dp 배열이 비어있을 경우에만 함수를 실행하도록 하고
비어있지 않은 경우에는 바로 계산해둔 dp 값을 리턴하게 하여 문제를 해결할 수 있다. dp 풀이를 연습하자


5.[BOJ11055](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ11055.java)

DP 문제를 드디어 성공하였다.
앞선 문제와 비슷한 문제였지만, 이번에는 가장 긴 길이가 아닌 증가 수열의 가장 큰 부분 합을 찾는 문제였다.
DP의 핵심은 한번 계산 완료한 것을 또 계산하지 않는 것이다. 그러기 위해서는 계산된 값이 dp 배열에 저장되어 있어야 한다.
dp값을 반환하는 recursive 함수를 만들었는데 입력받은 원소의 dp 배열이 비어있을 때만 함수가 동작하도록 설정하였고, dp 값이 이미 차있다면 그 값을 바로 반환하도록 하였다. 현재 원소를 기준으로 이전 원소들을 모두 탐색하여 현재 원소보다 작은 원소가 나올 경우 그 "작은 원소"의 dp 배열에 저장된 값에 내 현재 원소를 더해주는 방식을 택하였다. Math.max로 비교하고, for문을 써서 모든 원소에 대해 같은 동작을 수행하도록 하였다.
현재 원소보다 작은 원소들에 대해서 탐색하기 때문에 top-down 방식이다.

