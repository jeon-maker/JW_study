1. [BOJ2477](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ2477.java)

구현 - 성공

6각형의 모양이 특정되어 있기 때문에 가장 큰 가로 길이, 가장 큰 세로 길이를 곱해서 큰 틀 사각형의 넓이를 구한 뒤 작은 사각형 (빈 사각형)의 넓이를 빼주는 방식을 택하였다. 빈 사각형의 넓이를 빼주기 위해선 "1313","2323","1414","2424","3131","4141","3232","4242" 과 같은 2개의 숫자가 연속으로 반복되는 부분이 필연적으로 나오는데, 이때 중간 두개의 값을 곱해서 빼주면 된다. 주의할 점은 시작점이 특정되어있지 않기 때문에, 입력받은 숫자 6자리를 한번 더 그대로 붙여서 12자리로 만든 뒤에 최초로 반복되는 부분을 찾으면 된다.


2. [BOJ14247](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ14247.java)

그리디 - 성공

실패했던 원인 (메모리 초과 + 시간 초과) - 쓸데없이 2차원 배열 사용을 했음.

가장 빠르게 자라는 것을 늦게 자를수록 이득이다. 한 나무를 여러번 자를 수 있다는 조건이 있지만, 그냥 무조건 많은 나무들을 자르면서 빨리 자라는 나무는 늦게 자르는게 더 큰 양을 얻게 된다.
![image](https://user-images.githubusercontent.com/77326600/213654157-1d14c5aa-0cc0-447c-95d9-8d731a597926.png)
이 부분을 int로 하면 틀렸고, Long으로 하면 맞았다. 이유가 뭘까?

int는 4바이트이다 . 32비트로 양수,음수를 다 표현하기 때문에 -2,147,483,648부터 2,147,483,647까지의 값을 저장할 수 있다.문제의 조건에서 나무의 개수가 100,000개 까지 가능하고 , 나무들의 초기 길이가 100,000개, 자라는 속도가 10,000까지 가능하기 때문에 모두 최대값을 찍은 경우에는 100,000,000,000,000까지 답이 나올 수 있다.
따라서 int로 표현 가능한 범위를 초과하여 오답이 나오게 되는 듯 하다.
long은 8바이트로 64비트이다. 9,223,372,036,854,775,807까지 표현 가능하다.

참고로 Long과 Integer는 null을 사용할 수 있지만 long, int는 null을 사용할 수 없다.

앞으로 큰 범위의 수를 다루는 듯 하면 Long을 사용하도록 하자.

3.[BOJ1912](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ1912.java)

DP - 실패

DP는 역시 어렵다. dp 방식으로 풀어야 하는데 그렇지 못하게 풀어서 메모리 초과로 실패했다.

메모이제이션으로 풀어야 한다.
메모이제이션은 이전까지 탐색했던 값과 현재 위치의 값을 비교하여 큰 값을 저장하면 되는 것이다.
![image](https://user-images.githubusercontent.com/77326600/213665046-fd937373-c960-49d8-9793-12bff1bf55c9.png)
DP를 잘 풀 수 있다면 매우 쉬운 문제라고 한다.
DP를 풀 때 재귀를 이용해야 하는데 나는 항상 재귀를 생각 못하고 풀어왔다.
재귀를 사용해서 DP를 풀어야 한다는 것을 기억하면 좀 더 쉽게 접근할 수 있을 것 같다. 


4.[BOJ11053](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ11053.java)

DP - 실패

![image](https://user-images.githubusercontent.com/77326600/213871345-3649c6f0-75ee-41df-9e7c-b68ee7dde006.png

내 실패 코드이다.
반례를 찾았다.
9
1 2 3 4 5 1 2 3 4
를 입력하면 8이 출력된다. 직전의 값에만 비교를 해주기 때문인듯 하다. 직전 배열의 값에만 비교를 해주는게 아닌 다른 방법을 찾아야 한다. 뒤에 큰 숫자가 나오더라도 건너 뛸 수 있는 기능을 추가해야한다.

어렵다.. 실패 ㅠㅡㅠ

정답 코드
![image](https://user-images.githubusercontent.com/77326600/213872758-ee2911ae-f5b5-458a-b827-9511758da85a.png)


손코딩으로 써보니 이해가 되었다. 각 원소에서 이전 원소들에 대한 검증을 싹 다 해야한다. 재귀함수를 만들어서, dp 배열이 비어있을 경우에만 함수를 실행하도록 하고
비어있지 않은 경우에는 바로 계산해둔 dp 값을 리턴하게 하여 문제를 해결할 수 있다. dp 풀이를 연습하자


5.[BOJ11055](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ11055.java)

DP 문제를 드디어 성공하였다.
앞선 문제와 비슷한 문제였지만, 이번에는 가장 긴 길이가 아닌 증가 수열의 가장 큰 부분 합을 찾는 문제였다.
DP의 핵심은 한번 계산 완료한 것을 또 계산하지 않는 것이다. 그러기 위해서는 계산된 값이 dp 배열에 저장되어 있어야 한다.

![image](https://user-images.githubusercontent.com/77326600/213874627-f10777c1-a9bd-427d-904f-c93212595271.png)


dp값을 반환하는 recursive 함수를 만들었는데 입력받은 원소의 dp 배열이 비어있을 때만 함수가 동작하도록 설정하였고, dp 값이 이미 차있다면 그 값을 바로 반환하도록 하였다. 현재 원소를 기준으로 이전 원소들을 모두 탐색하여 현재 원소보다 작은 원소가 나올 경우 그 "작은 원소"의 dp 배열에 저장된 값에 내 현재 원소를 더해주는 방식을 택하였다. Math.max로 비교하고, for문을 써서 모든 원소에 대해 같은 동작을 수행하도록 하였다.
현재 원소보다 작은 원소들에 대해서 탐색하기 때문에 top-down 방식이다.


6.[BOJ11722](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ11722.java)

![image](https://user-images.githubusercontent.com/77326600/214795407-46361344-6dc9-4b34-a672-1306e4b201f7.png)

이번에는 감소하는 수열의 최대 길이를 구하는 문제였다. 가장 뒤에 있는 원소부터 시작을 하는 top-down 방식으로 풀이했다.
dp 배열이 비어있을 경우 기본값인 1을 넣어주고, 현재 원소를 기준으로 이전 원소에 작은 원소가 등장할 경우 현재 dp 값을 업데이트 시켜주며 풀었는데, 이때 주의할 점은
조건에 맞는 원소를 발견했을 때
dp[k] = Math.max(d[[k], reculsive(i) + 1) 
여기서 reculsive는 재귀하여 dp값을 채워가는 메서드이고, + 1은 조건에 맞는 값을 설정해주면 된다.

![image](https://user-images.githubusercontent.com/77326600/214796257-a7fbc47b-6ece-4306-bcf0-e85e512f8a73.png)

모든 dp원소에 대한 값이 채워지지 않아도 정답을 맞출 수 있다 ! 조건에 맞는 원소들만 딱 딱 골라서 해결해주면 된다.


6.[BOJ9095](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ9095.java)


규칙을 찾는게 중요한 문제. DP를 풀 때는 규칙을 찾으려고 노력해보자.
규칙만 찾으면 코드가 쉽게 이해될 수 있다.
