1. [BOJ2477](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ2477.java)

구현 - 성공

6각형의 모양이 특정되어 있기 때문에 가장 큰 가로 길이, 가장 큰 세로 길이를 곱해서 큰 틀 사각형의 넓이를 구한 뒤 작은 사각형 (빈 사각형)의 넓이를 빼주는 방식을 택하였다. 빈 사각형의 넓이를 빼주기 위해선 "1313","2323","1414","2424","3131","4141","3232","4242" 과 같은 2개의 숫자가 연속으로 반복되는 부분이 필연적으로 나오는데, 이때 중간 두개의 값을 곱해서 빼주면 된다. 주의할 점은 시작점이 특정되어있지 않기 때문에, 입력받은 숫자 6자리를 한번 더 그대로 붙여서 12자리로 만든 뒤에 최초로 반복되는 부분을 찾으면 된다.


2. [BOJ14247](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ14247.java)

그리디 - 성공

실패했던 원인 (메모리 초과 + 시간 초과) - 쓸데없이 2차원 배열 사용을 했음.

가장 빠르게 자라는 것을 늦게 자를수록 이득이다. 한 나무를 여러번 자를 수 있다는 조건이 있지만, 그냥 무조건 많은 나무들을 자르면서 빨리 자라는 나무는 늦게 자르는게 더 큰 양을 얻게 된다.
![image](https://user-images.githubusercontent.com/77326600/213654157-1d14c5aa-0cc0-447c-95d9-8d731a597926.png)
이 부분을 int로 하면 틀렸고, Long으로 하면 맞았다. 이유가 뭘까?

int는 4바이트이다 . 32비트로 양수,음수를 다 표현하기 때문에 -2,147,483,648부터 2,147,483,647까지의 값을 저장할 수 있다.문제의 조건에서 나무의 개수가 100,000개 까지 가능하고 , 나무들의 초기 길이가 100,000개, 자라는 속도가 10,000까지 가능하기 때문에 모두 최대값을 찍은 경우에는 100,000,000,000,000까지 답이 나올 수 있다.
따라서 int로 표현 가능한 범위를 초과하여 오답이 나오게 되는 듯 하다.
long은 8바이트로 64비트이다. 9,223,372,036,854,775,807까지 표현 가능하다.

참고로 Long과 Integer는 null을 사용할 수 있지만 long, int는 null을 사용할 수 없다.

앞으로 큰 범위의 수를 다루는 듯 하면 Long을 사용하도록 하자.

3.[BOJ1912](https://github.com/jeon-maker/JW_study/blob/main/Jeon/BOJ1912.java)

DP - 실패

DP는 역시 어렵다. dp 방식으로 풀어야 하는데 그렇지 못하게 풀어서 메모리 초과로 실패했다.

메모이제이션으로 풀어야 한다.
메모이제이션은 이전까지 탐색했던 값과 현재 위치의 값을 비교하여 큰 값을 저장하면 되는 것이다.
![image](https://user-images.githubusercontent.com/77326600/213665046-fd937373-c960-49d8-9793-12bff1bf55c9.png)
DP를 잘 풀 수 있다면 매우 쉬운 문제라고 한다.
DP를 풀 때 재귀를 이용해야 하는데 나는 항상 재귀를 생각 못하고 풀어왔다.
재귀를 사용해서 DP를 풀어야 한다는 것을 기억하면 좀 더 쉽게 접근할 수 있을 것 같다. 



